/**
 * Git Integration
 *
 * Handles git operations for project initialization,
 * including commits and .gitattributes setup.
 */

import * as path from 'path';
import simpleGit, { SimpleGit } from 'simple-git';
import { writeFileWithRetry } from '../utils/fs-resilient.js';
import { logger } from '../utils/logger.js';

/**
 * Initialize git repository if not already initialized
 *
 * @param projectRoot - Project root directory
 * @returns Git instance
 */
export async function ensureGitRepository(
  projectRoot: string = process.cwd()
): Promise<SimpleGit> {
  const git = simpleGit(projectRoot);

  try {
    // Check if already a git repository
    const isRepo = await git.checkIsRepo();

    if (!isRepo) {
      logger.info({ projectRoot }, 'Initializing git repository');
      await git.init();
      logger.info('Git repository initialized');
    } else {
      logger.debug('Git repository already exists');
    }

    return git;
  } catch (error) {
    logger.error({ error }, 'Failed to initialize git repository');
    throw new Error(
      `Failed to initialize git repository: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}

/**
 * Create .gitattributes file for LF line endings
 *
 * @param projectRoot - Project root directory
 */
export async function createGitAttributes(
  projectRoot: string = process.cwd()
): Promise<void> {
  const gitattributesPath = path.join(projectRoot, '.gitattributes');

  const content = `# Contextualizer - Enforce LF line endings
* text=auto eol=lf

# Shell scripts must use LF
*.sh text eol=lf

# Windows batch files must use CRLF
*.bat text eol=crlf

# Binary files
*.png binary
*.jpg binary
*.jpeg binary
*.gif binary
*.ico binary
*.pdf binary
`;

  await writeFileWithRetry(gitattributesPath, content);

  logger.info({ gitattributesPath }, 'Created .gitattributes file');
}

/**
 * Create initialization commit
 *
 * @param projectRoot - Project root directory
 * @param presetName - Preset name used for initialization
 * @param files - List of files to commit
 */
export async function createInitCommit(
  projectRoot: string = process.cwd(),
  presetName: string,
  files: string[]
): Promise<void> {
  try {
    const git = await ensureGitRepository(projectRoot);

    logger.info(
      { presetName, fileCount: files.length },
      'Creating initialization commit'
    );

    // Add files to staging
    await git.add(files);

    // Create commit
    const message = `Initialize Contextualizer with ${presetName} preset

Generated by Contextualizer MCP Server
- Preset: ${presetName}
- Files: ${files.length}
- Date: ${new Date().toISOString()}

This commit includes:
${files.map((f) => `  - ${f}`).join('\n')}
`;

    await git.commit(message);

    logger.info({ presetName }, 'Initialization commit created');
  } catch (error) {
    logger.error({ error }, 'Failed to create initialization commit');
    throw new Error(
      `Failed to create initialization commit: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}

/**
 * Check if working directory is clean
 *
 * @param projectRoot - Project root directory
 * @returns True if working directory is clean
 */
export async function isWorkingDirectoryClean(
  projectRoot: string = process.cwd()
): Promise<boolean> {
  try {
    const git = simpleGit(projectRoot);

    // Check if it's a git repository
    const isRepo = await git.checkIsRepo();
    if (!isRepo) {
      return true; // Not a git repo, consider it clean
    }

    const status = await git.status();
    return status.isClean();
  } catch (error) {
    logger.warn({ error }, 'Failed to check git status');
    return true; // Assume clean on error
  }
}

/**
 * Get list of uncommitted files
 *
 * @param projectRoot - Project root directory
 * @returns List of uncommitted file paths
 */
export async function getUncommittedFiles(
  projectRoot: string = process.cwd()
): Promise<string[]> {
  try {
    const git = simpleGit(projectRoot);

    // Check if it's a git repository
    const isRepo = await git.checkIsRepo();
    if (!isRepo) {
      return [];
    }

    const status = await git.status();
    return [
      ...status.not_added,
      ...status.created,
      ...status.modified,
      ...status.deleted,
    ];
  } catch (error) {
    logger.warn({ error }, 'Failed to get uncommitted files');
    return [];
  }
}

/**
 * Stage specific files
 *
 * @param projectRoot - Project root directory
 * @param files - Files to stage
 */
export async function stageFiles(
  projectRoot: string = process.cwd(),
  files: string[]
): Promise<void> {
  try {
    const git = simpleGit(projectRoot);

    logger.debug({ fileCount: files.length }, 'Staging files');

    await git.add(files);

    logger.debug({ fileCount: files.length }, 'Files staged');
  } catch (error) {
    logger.error({ error }, 'Failed to stage files');
    throw new Error(
      `Failed to stage files: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}

/**
 * Check if git is available
 *
 * @returns True if git is available
 */
export async function isGitAvailable(): Promise<boolean> {
  try {
    const git = simpleGit();
    await git.version();
    return true;
  } catch (error) {
    logger.warn('Git is not available');
    return false;
  }
}
