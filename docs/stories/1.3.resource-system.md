# Story 1.3: Resource System

<!-- Powered by BMADâ„¢ Core -->

## Status
ðŸ“ Draft - 2025-10-19

## Story

**As a** developer using Claude for AI-assisted development,
**I want** three MCP resources that provide configuration, diagnostics, and preset data,
**so that** Claude can read project state and available presets without invoking tools.

## Acceptance Criteria

1. Resource provider architecture implemented with MCPResource interface
2. Config resource (contextualizer://config) returns placeholder YAML configuration
3. Diagnostics resource (contextualizer://diagnostics) returns placeholder JSON report
4. Presets resource (contextualizer://presets) returns actual preset definitions (minimal, web-fullstack, hackathon)
5. All resources registered in RESOURCES array and discoverable via resources/list
6. Resource reading via resources/read works for all 3 resources
7. Proper MIME types: config (application/x-yaml), diagnostics (application/json), presets (application/json)
8. Resources return read-only data (no modification capability)
9. Comprehensive unit tests for each resource provider
10. Integration tests verify resource reading through MCP protocol

## Tasks / Subtasks

- [ ] **Task 1: Create Preset Definitions** (AC: 4, 7)
  - [ ] Create `src/config/presets.ts` with preset data
  - [ ] Define minimal preset (basic context monitoring, no hooks, minimal memory)
  - [ ] Define web-fullstack preset (full context monitoring, pre-commit hook, agents/skills)
  - [ ] Define hackathon preset (relaxed monitoring, disabled hooks, minimal overhead)
  - [ ] Export presets as typed constant array
  - [ ] Unit test: Minimal preset has correct structure
  - [ ] Unit test: Web-fullstack preset includes agents and skills
  - [ ] Unit test: Hackathon preset has relaxed settings
  - [ ] Unit test: All presets have required fields

- [ ] **Task 2: Implement Config Resource** (AC: 2, 5, 7, 8)
  - [ ] Create `src/resources/config-resource.ts`
  - [ ] Implement configResourceProvider returning placeholder YAML
  - [ ] Return empty config with version and preset placeholder
  - [ ] Set MIME type to `application/x-yaml`
  - [ ] Export configResource definition (uri, name, description, mimeType, provider)
  - [ ] Unit test: Provider returns valid YAML structure
  - [ ] Unit test: MIME type is application/x-yaml
  - [ ] Unit test: URI matches contextualizer://config
  - [ ] Unit test: Placeholder indicates Epic 6 implementation

- [ ] **Task 3: Implement Diagnostics Resource** (AC: 3, 5, 7, 8)
  - [ ] Create `src/resources/diagnostics-resource.ts`
  - [ ] Implement diagnosticsResourceProvider returning placeholder JSON
  - [ ] Return empty diagnostic report structure (timestamp, summary, checks array)
  - [ ] Set MIME type to `application/json`
  - [ ] Export diagnosticsResource definition
  - [ ] Unit test: Provider returns valid JSON structure
  - [ ] Unit test: MIME type is application/json
  - [ ] Unit test: URI matches contextualizer://diagnostics
  - [ ] Unit test: Report includes timestamp, summary, checks
  - [ ] Unit test: Placeholder indicates Epic 5 implementation

- [ ] **Task 4: Implement Presets Resource** (AC: 4, 5, 7, 8)
  - [ ] Create `src/resources/presets-resource.ts`
  - [ ] Import preset definitions from `src/config/presets.ts`
  - [ ] Implement presetsResourceProvider returning actual preset data
  - [ ] Format as JSON with all 3 presets (minimal, web-fullstack, hackathon)
  - [ ] Set MIME type to `application/json`
  - [ ] Export presetsResource definition
  - [ ] Unit test: Provider returns all 3 presets
  - [ ] Unit test: MIME type is application/json
  - [ ] Unit test: URI matches contextualizer://presets
  - [ ] Unit test: Each preset has name, description, and configuration
  - [ ] Unit test: JSON is properly formatted and parseable

- [ ] **Task 5: Register Resources in Registry** (AC: 1, 5, 6)
  - [ ] Update `src/resources/index.ts` to import all 3 resources
  - [ ] Add all resources to RESOURCES array export
  - [ ] Verify resources are discoverable via ListResourcesRequestSchema handler
  - [ ] Verify resource reading works via ReadResourceRequestSchema handler
  - [ ] Unit test: RESOURCES array contains all 3 resources
  - [ ] Unit test: Each resource has required properties (uri, name, description, mimeType, provider)
  - [ ] Unit test: Resource URIs are unique in registry

- [ ] **Task 6: Integration Testing** (AC: 6, 10)
  - [ ] Create `tests/integration/resource-reading.test.ts`
  - [ ] Test: resources/list returns all 3 resources with correct metadata
  - [ ] Test: resources/read works for contextualizer://config
  - [ ] Test: resources/read works for contextualizer://diagnostics
  - [ ] Test: resources/read works for contextualizer://presets
  - [ ] Test: Config resource returns YAML with correct MIME type
  - [ ] Test: Diagnostics resource returns JSON with correct MIME type
  - [ ] Test: Presets resource returns JSON with 3 presets
  - [ ] Test: resources/read with invalid URI returns error
  - [ ] Test: Resource content is properly formatted

- [ ] **Task 7: Comprehensive Unit Testing** (AC: 9)
  - [ ] Create `tests/unit/config/presets.test.ts` with 8+ tests
  - [ ] Create `tests/unit/resources/config-resource.test.ts` with 6+ tests
  - [ ] Create `tests/unit/resources/diagnostics-resource.test.ts` with 6+ tests
  - [ ] Create `tests/unit/resources/presets-resource.test.ts` with 8+ tests
  - [ ] Verify coverage: 80%+ for all resource files
  - [ ] Verify coverage: 90%+ for preset definitions

## Dev Notes

### Previous Story Insights

**From Story 1.1** (COMPLETED):
- MCP server skeleton with empty RESOURCES array ready
- Type definitions in place: MCPResource, ResourceContent
- Server handlers ready: ListResourcesRequestSchema, ReadResourceRequestSchema
- Logger utility available for resource logging
- Testing infrastructure (Vitest) configured

**From Story 1.2** (COMPLETED):
- Error handling infrastructure available (ContextualizerError hierarchy)
- Testing patterns established (unit + integration)
- Placeholder implementation pattern: return informative messages about future functionality
- 188 tests passing with 96.87% coverage baseline

**Key Learnings**:
- Resources are READ-ONLY (Claude reads, doesn't modify)
- Resources return data in appropriate MIME types
- Placeholder resources return empty structures, except presets which return actual data
- Integration tests spawn server and verify MCP protocol flow

### Architecture Overview

**Source Context**: This story implements resources described in:
- [Source: architecture/mcp-server.md#resource-system-interface]
- [Source: architecture/mcp-server.md#tool-system-interface]
- [Source: architecture/integration-data.md#preset-schema]

### Resource System Requirements

[Source: architecture/mcp-server.md#resource-system-interface]

**MCPResource Interface**:
```typescript
interface MCPResource {
  uri: string; // contextualizer://config, contextualizer://diagnostics, contextualizer://presets
  name: string;
  description: string;
  mimeType: string;
  provider: () => Promise<ResourceContent>;
}

interface ResourceContent {
  uri: string;
  mimeType: string;
  text?: string;
  blob?: string;
}
```

**Resource Provider Pattern**:
Resources are functions that return ResourceContent. They are:
- Asynchronous (return Promise<ResourceContent>)
- Read-only (no side effects)
- Cacheable (same input â†’ same output)
- Fast (< 100ms target)

### Resource Specifications

#### 1. Config Resource

[Source: architecture/mcp-server.md#resource-system-interface]

**URI**: `contextualizer://config`
**MIME Type**: `application/x-yaml`
**Purpose**: Provide current effective configuration with overrides applied

**Placeholder Behavior** (Story 1.3):
Return empty configuration structure indicating implementation is pending Epic 6.

**Expected Return**:
```yaml
# Contextualizer Configuration (Placeholder)
# Full implementation coming in Epic 6: Memory Management & Configuration

version: "1.0.0"
preset: "placeholder"

# This resource will provide:
# - Current effective configuration with overrides applied
# - Merged preset defaults
# - Environment variable overrides
# - Real-time updates when configuration changes
```

**Implementation Notes**:
- Return YAML as text string
- Include comments explaining placeholder status
- Format should match final ConfigSchema structure
- No file I/O (just return static placeholder YAML)

#### 2. Diagnostics Resource

[Source: architecture/mcp-server.md#resource-system-interface]

**URI**: `contextualizer://diagnostics`
**MIME Type**: `application/json`
**Purpose**: Provide latest doctor run results

**Placeholder Behavior** (Story 1.3):
Return empty diagnostic report structure indicating implementation is pending Epic 5.

**Expected Return**:
```json
{
  "timestamp": "2025-10-19T00:00:00Z",
  "version": "1.0.0",
  "summary": {
    "total": 0,
    "passed": 0,
    "warnings": 0,
    "failures": 0,
    "message": "Placeholder - full implementation coming in Epic 5: Diagnostics & Best Practices"
  },
  "checks": []
}
```

**Implementation Notes**:
- Return JSON as text string
- Include current timestamp
- Match DiagnosticReportSchema structure from [Source: architecture/integration-data.md#diagnostic-report-schema]
- No file I/O (just return static placeholder JSON)

#### 3. Presets Resource

[Source: architecture/mcp-server.md#resource-system-interface]

**URI**: `contextualizer://presets`
**MIME Type**: `application/json`
**Purpose**: Provide available preset definitions

**Full Implementation** (Story 1.3):
This is the ONLY resource with actual implementation in Story 1.3. Return real preset definitions.

**Expected Return**:
```json
{
  "presets": [
    {
      "name": "minimal",
      "description": "Minimal preset with basic context monitoring",
      "installationTime": "~30 seconds",
      "contextMonitoring": {
        "warningThreshold": 80,
        "criticalThreshold": 95,
        "boundaryDetection": "balanced"
      },
      "hooks": {
        "preCommit": {
          "enabled": false
        }
      },
      "memory": {
        "sections": [
          { "title": "Project Context", "content": "# Project Context\n\nProject-specific information." }
        ]
      }
    },
    {
      "name": "web-fullstack",
      "description": "Full-stack web development with Next.js, React, TypeScript",
      "installationTime": "~2 minutes",
      "contextMonitoring": {
        "warningThreshold": 75,
        "criticalThreshold": 90,
        "boundaryDetection": "aggressive"
      },
      "hooks": {
        "preCommit": {
          "enabled": true,
          "strictness": "balanced",
          "checks": [
            { "name": "typecheck", "failOn": "errors" },
            { "name": "lint", "failOn": "errors" },
            { "name": "test", "failOn": "errors" }
          ]
        }
      },
      "memory": {
        "sections": [
          { "title": "Tech Stack", "content": "# Tech Stack\n\n- Next.js\n- React\n- TypeScript\n- Tailwind CSS" },
          { "title": "Architecture Patterns", "content": "# Architecture Patterns\n\n- Component-driven development\n- Server/client component separation" }
        ],
        "context7Libraries": ["/vercel/next.js", "/facebook/react", "/microsoft/typescript"]
      },
      "skills": ["nextjs-expert", "react-expert", "typescript-expert"],
      "subagents": ["code-reviewer", "test-architect", "doc-writer"],
      "codingStandards": ["typescript-strict", "react-best-practices", "tailwind-utility-first"]
    },
    {
      "name": "hackathon",
      "description": "Fast iteration mode for hackathons and prototypes",
      "installationTime": "~15 seconds",
      "contextMonitoring": {
        "warningThreshold": 90,
        "criticalThreshold": 98,
        "boundaryDetection": "conservative"
      },
      "hooks": {
        "preCommit": {
          "enabled": false
        }
      },
      "memory": {
        "sections": [
          { "title": "Project Goals", "content": "# Project Goals\n\nRapid prototyping and experimentation." }
        ]
      }
    }
  ]
}
```

**Implementation Notes**:
- Define presets in `src/config/presets.ts` as TypeScript constants
- Import into `src/resources/presets-resource.ts`
- Convert to JSON string for ResourceContent
- Match PresetSchema from [Source: architecture/integration-data.md#preset-schema]
- Include all fields from architecture spec

### Preset Definitions Data

[Source: architecture/integration-data.md#preset-schema]

**Minimal Preset**:
- Basic context monitoring (80/95 thresholds)
- Balanced boundary detection
- No pre-commit hook
- Single memory section (Project Context)
- No skills, subagents, or coding standards
- Installation time: ~30 seconds

**Web-Fullstack Preset**:
- Aggressive context monitoring (75/90 thresholds)
- Aggressive boundary detection
- Pre-commit hook enabled (balanced strictness)
- Pre-commit checks: typecheck, lint, test (fail on errors)
- Memory sections: Tech Stack, Architecture Patterns
- Context7 libraries: Next.js, React, TypeScript
- Skills: nextjs-expert, react-expert, typescript-expert
- Subagents: code-reviewer, test-architect, doc-writer
- Coding standards: typescript-strict, react-best-practices, tailwind-utility-first
- Installation time: ~2 minutes

**Hackathon Preset**:
- Relaxed context monitoring (90/98 thresholds)
- Conservative boundary detection
- No pre-commit hook
- Single memory section (Project Goals)
- No skills, subagents, or coding standards
- Installation time: ~15 seconds

### File Locations

[Source: architecture/integration-data.md#file-system-layout]

**New Files to Create**:
- `src/config/presets.ts` - Preset data definitions
- `src/resources/config-resource.ts` - Config resource implementation
- `src/resources/diagnostics-resource.ts` - Diagnostics resource implementation
- `src/resources/presets-resource.ts` - Presets resource implementation

**Files to Modify**:
- `src/resources/index.ts` - Import and register all 3 resources in RESOURCES array

**Test Files to Create**:
- `tests/unit/config/presets.test.ts` - Preset data tests
- `tests/unit/resources/config-resource.test.ts` - Config resource tests
- `tests/unit/resources/diagnostics-resource.test.ts` - Diagnostics resource tests
- `tests/unit/resources/presets-resource.test.ts` - Presets resource tests
- `tests/integration/resource-reading.test.ts` - Resource reading integration tests

### Resource Implementation Pattern

[Source: architecture/mcp-server.md#resource-system-interface]

**Standard Resource Structure**:
```typescript
// src/resources/example-resource.ts
import type { MCPResource, ResourceContent } from '../types/mcp.js';

/**
 * Provider function for example resource
 */
async function exampleResourceProvider(): Promise<ResourceContent> {
  // Generate or fetch resource data
  const data = "resource content here";

  return {
    uri: "contextualizer://example",
    mimeType: "text/plain",
    text: data,
  };
}

/**
 * Example resource definition
 */
export const exampleResource: MCPResource = {
  uri: "contextualizer://example",
  name: "Example Resource",
  description: "Description of what this resource provides",
  mimeType: "text/plain",
  provider: exampleResourceProvider,
};
```

**Key Patterns**:
- Provider functions are async (return Promise)
- Provider functions have no parameters (stateless)
- ResourceContent must include uri and mimeType
- Use text field for string data (YAML, JSON)
- Use blob field for binary data (images, etc.)

### MIME Type Guidelines

**YAML Content**: `application/x-yaml`
- Used for: Config resource
- Return as: text string

**JSON Content**: `application/json`
- Used for: Diagnostics resource, Presets resource
- Return as: text string (JSON.stringify with formatting)

### Server Integration

[Source: architecture/mcp-server.md#server-lifecycle]

**Resource Handlers** (already implemented in Story 1.1):

```typescript
// resources/list handler
server.setRequestHandler(ListResourcesRequestSchema, async () => ({
  resources: RESOURCES.map(r => ({
    uri: r.uri,
    name: r.name,
    description: r.description,
    mimeType: r.mimeType
  })),
}));

// resources/read handler
server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
  const resource = RESOURCES.find(r => r.uri === request.params.uri);
  if (!resource) throw new Error(`Unknown resource: ${request.params.uri}`);

  return await resource.provider();
});
```

**No Changes Required** to server.ts - handlers are already in place from Story 1.1.

### Logging Integration

[Source: architecture/mcp-server.md#server-lifecycle]

**Resource Logging Pattern**:
```typescript
import { logger } from '../utils/logger.js';

async function resourceProvider(): Promise<ResourceContent> {
  logger.debug({ resource: 'resource_name' }, 'Resource read');

  // Generate resource content
  const content = { /* ... */ };

  return content;
}
```

**Logger Available** (from Story 1.1):
- `logger.debug()` - Debug level (use for resource reads)
- `logger.info()` - Info level
- `logger.error()` - Error level

### Testing Strategy

#### Testing Standards

[Source: architecture/security-performance-testing.md#testing-architecture]

**Test Framework**: Vitest (already configured)

**Coverage Requirements**:
- Lines: 80%+
- Functions: 80%+
- Branches: 75%+
- Statements: 80%+

**Test File Structure**:
```
tests/
â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ presets.test.ts
â”‚   â””â”€â”€ resources/
â”‚       â”œâ”€â”€ config-resource.test.ts
â”‚       â”œâ”€â”€ diagnostics-resource.test.ts
â”‚       â””â”€â”€ presets-resource.test.ts
â””â”€â”€ integration/
    â””â”€â”€ resource-reading.test.ts
```

#### Unit Test Requirements

**Preset Data Tests** (`tests/unit/config/presets.test.ts`):
1. Minimal preset has correct structure
2. Minimal preset has required fields (name, description, contextMonitoring, hooks, memory)
3. Web-fullstack preset includes agents and skills
4. Web-fullstack preset has Context7 libraries
5. Web-fullstack preset has pre-commit hook enabled
6. Hackathon preset has relaxed thresholds
7. Hackathon preset has pre-commit hook disabled
8. All presets are valid (no missing required fields)

**Config Resource Tests**:
1. Provider returns ResourceContent with correct uri
2. Provider returns MIME type application/x-yaml
3. Provider returns valid YAML string
4. YAML includes placeholder comment
5. YAML includes version and preset fields
6. Resource definition has correct metadata

**Diagnostics Resource Tests**:
1. Provider returns ResourceContent with correct uri
2. Provider returns MIME type application/json
3. Provider returns valid JSON string
4. JSON includes timestamp, summary, checks
5. JSON is parseable
6. Resource definition has correct metadata

**Presets Resource Tests**:
1. Provider returns ResourceContent with correct uri
2. Provider returns MIME type application/json
3. Provider returns valid JSON string
4. JSON includes all 3 presets (minimal, web-fullstack, hackathon)
5. JSON is parseable
6. Each preset has required fields
7. Web-fullstack preset includes skills array
8. Resource definition has correct metadata

**Example Unit Test Pattern**:
```typescript
import { describe, it, expect } from 'vitest';
import { configResource } from '../../src/resources/config-resource';

describe('config resource', () => {
  describe('provider behavior', () => {
    it('returns ResourceContent with correct uri', async () => {
      const result = await configResource.provider();
      expect(result.uri).toBe('contextualizer://config');
    });

    it('returns MIME type application/x-yaml', async () => {
      const result = await configResource.provider();
      expect(result.mimeType).toBe('application/x-yaml');
    });

    it('returns valid YAML string', async () => {
      const result = await configResource.provider();
      expect(result.text).toBeTruthy();
      expect(result.text).toContain('version:');
      expect(result.text).toContain('preset:');
    });

    it('includes placeholder comment', async () => {
      const result = await configResource.provider();
      expect(result.text).toContain('Placeholder');
      expect(result.text).toContain('Epic 6');
    });
  });

  describe('resource definition', () => {
    it('has correct metadata', () => {
      expect(configResource.uri).toBe('contextualizer://config');
      expect(configResource.name).toBeTruthy();
      expect(configResource.description).toBeTruthy();
      expect(configResource.mimeType).toBe('application/x-yaml');
      expect(configResource.provider).toBeTypeOf('function');
    });
  });
});
```

#### Integration Test Requirements

[Source: architecture/security-performance-testing.md#integration-test-strategy]

**Test Scenarios**:
1. resources/list returns all 3 resources
2. resources/list includes correct metadata (uri, name, description, mimeType)
3. resources/read succeeds for contextualizer://config
4. resources/read succeeds for contextualizer://diagnostics
5. resources/read succeeds for contextualizer://presets
6. Config resource returns YAML with correct MIME type
7. Diagnostics resource returns JSON with correct MIME type
8. Presets resource returns JSON with 3 presets
9. resources/read with invalid URI returns error
10. Resource content is properly formatted

**Example Integration Test**:
```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { spawn } from 'child_process';
import type { ChildProcess } from 'child_process';

describe('Resource Reading Integration', () => {
  let server: ChildProcess;

  beforeAll(async () => {
    server = spawn('node', ['dist/server.js']);
    await new Promise(resolve => setTimeout(resolve, 1000));
  });

  afterAll(() => {
    server.kill();
  });

  it('lists all 3 resources', async () => {
    server.stdin.write(JSON.stringify({
      jsonrpc: '2.0',
      method: 'resources/list',
      id: 1,
    }) + '\n');

    const response = await new Promise<any>((resolve) => {
      server.stdout.once('data', (data) => {
        resolve(JSON.parse(data.toString()));
      });
    });

    expect(response.result.resources).toHaveLength(3);
    expect(response.result.resources.map(r => r.uri)).toContain('contextualizer://config');
    expect(response.result.resources.map(r => r.uri)).toContain('contextualizer://diagnostics');
    expect(response.result.resources.map(r => r.uri)).toContain('contextualizer://presets');
  });

  it('reads config resource successfully', async () => {
    server.stdin.write(JSON.stringify({
      jsonrpc: '2.0',
      method: 'resources/read',
      params: { uri: 'contextualizer://config' },
      id: 2,
    }) + '\n');

    const response = await new Promise<any>((resolve) => {
      server.stdout.once('data', (data) => {
        resolve(JSON.parse(data.toString()));
      });
    });

    expect(response.result.uri).toBe('contextualizer://config');
    expect(response.result.mimeType).toBe('application/x-yaml');
    expect(response.result.text).toContain('version:');
  });

  it('reads presets resource and returns 3 presets', async () => {
    server.stdin.write(JSON.stringify({
      jsonrpc: '2.0',
      method: 'resources/read',
      params: { uri: 'contextualizer://presets' },
      id: 3,
    }) + '\n');

    const response = await new Promise<any>((resolve) => {
      server.stdout.once('data', (data) => {
        resolve(JSON.parse(data.toString()));
      });
    });

    expect(response.result.uri).toBe('contextualizer://presets');
    expect(response.result.mimeType).toBe('application/json');

    const presets = JSON.parse(response.result.text);
    expect(presets.presets).toHaveLength(3);
    expect(presets.presets.map(p => p.name)).toContain('minimal');
    expect(presets.presets.map(p => p.name)).toContain('web-fullstack');
    expect(presets.presets.map(p => p.name)).toContain('hackathon');
  });
});
```

### Performance Targets

[Source: architecture/security-performance-testing.md#performance-targets]

- **Resource read**: < 100ms (target from architecture)
- **Provider execution**: < 10ms (static data, no I/O)
- **JSON formatting**: < 5ms (for presets resource)

### Implementation Notes

**Placeholder Implementation Strategy**:
1. Config and Diagnostics resources: Return minimal placeholder structures
2. Presets resource: Return ACTUAL data (fully implemented in this story)
3. No file I/O operations (static data only)
4. No caching yet (caching comes in later epics)
5. Resources are synchronous in practice but async by interface

**Data Format Requirements**:
- YAML: Use template literals with proper indentation
- JSON: Use JSON.stringify with 2-space indentation for readability
- Include comments in YAML explaining placeholder status
- Include message fields in JSON placeholders

**TypeScript Best Practices**:
- Define preset data with `as const` for type safety
- Export types inferred from preset data
- Use strict typing for ResourceContent return values
- No `any` types except for MCP SDK compatibility

**Testing Focus**:
- Verify MIME types are correct
- Verify data formats (YAML parseable, JSON parseable)
- Verify all required fields present
- Verify placeholder messages clear about future implementation
- Integration tests verify full MCP protocol flow

**Dependencies** (already installed):
- `@modelcontextprotocol/sdk` - MCP types
- `pino` - Logger

### Definition of Done

- [ ] All acceptance criteria met
- [ ] All tasks completed
- [ ] 3 resources implemented (config, diagnostics, presets)
- [ ] Preset data definitions complete with all 3 presets
- [ ] All resources registered in RESOURCES array
- [ ] Unit tests: 30+ tests total (8+ presets, 6+ per resource)
- [ ] Integration tests: 10+ tests covering all resources
- [ ] Test coverage: 80%+ lines, functions, statements
- [ ] Build completes without errors (`npm run build`)
- [ ] All tests pass (`npm test`)
- [ ] No TypeScript errors (`tsc --noEmit`)
- [ ] Code follows established patterns from Story 1.1 & 1.2
- [ ] Documentation comments added to all public APIs

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-19 | 1.0.0 | Initial story draft created | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
- **Model**: (To be filled by Dev Agent)
- **Agent**: (To be filled by Dev Agent)
- **Date**: (To be filled by Dev Agent)

### Debug Log References
- (To be filled by Dev Agent)

### Completion Notes List
- (To be filled by Dev Agent)

### File List
- (To be filled by Dev Agent)

## QA Results

**QA Agent**: (To be filled by QA Agent)
**QA Date**: (To be filled by QA Agent)
**QA Status**: (To be filled by QA Agent)

### Acceptance Criteria Validation
- (To be filled by QA Agent)

### Test Results
- (To be filled by QA Agent)

### Issues Found
- (To be filled by QA Agent)

### QA Recommendation
- (To be filled by QA Agent)
