# Story 1.2: Tool Registry System

<!-- Powered by BMAD™ Core -->

## Status
✅ **COMPLETED** - 2025-10-19

## Story

**As a** developer using Claude for AI-assisted development,
**I want** the five core MCP tools implemented and registered,
**so that** Claude can invoke Contextualizer functionality through natural language commands.

## Acceptance Criteria

1. Tool registry system implements 5 core tools: init_project, run_doctor, configure_hooks, manage_memory, get_config
2. Each tool has complete Zod schema for parameter validation
3. Each tool has proper error handling using ContextualizerError hierarchy
4. Each tool returns structured ToolResult with appropriate content
5. Tool handlers are wrapped with error handling wrapper
6. All tools registered in TOOLS array and discoverable via tools/list
7. Tool invocation via tools/call works for all 5 tools
8. Each tool has placeholder implementation (actual functionality comes in later epics)
9. Comprehensive unit tests for each tool (parameter validation, error cases, success cases)
10. Integration tests verify tool invocation through MCP protocol

## Tasks / Subtasks

- [x] **Task 1: Create Error Handling Infrastructure** (AC: 3, 5)
  - [x] Create `src/utils/errors.ts` with ContextualizerError base class
  - [x] Implement ValidationError subclass
  - [x] Implement FileOperationError subclass
  - [x] Implement ConflictError subclass
  - [x] Create wrapToolHandler function for consistent error handling
  - [x] Add error message formatting utilities
  - [x] Unit test: Error class hierarchy
  - [x] Unit test: wrapToolHandler wraps errors correctly
  - [x] Unit test: Error messages are user-friendly

- [x] **Task 2: Implement init_project Tool** (AC: 1, 2, 4, 8)
  - [x] Create `src/tools/init-project.ts`
  - [x] Define InitProjectSchema using Zod (preset, options parameters)
  - [x] Implement initProjectHandler with placeholder logic
  - [x] Return structured ToolResult: "✅ init_project registered (implementation pending Epic 2)"
  - [x] Export initProject tool definition with name, description, schema, handler
  - [x] Unit test: Schema validation (valid preset values)
  - [x] Unit test: Schema validation (invalid preset rejected)
  - [x] Unit test: Handler returns success ToolResult
  - [x] Unit test: Optional parameters handled correctly

- [x] **Task 3: Implement run_doctor Tool** (AC: 1, 2, 4, 8)
  - [x] Create `src/tools/run-doctor.ts`
  - [x] Define RunDoctorSchema using Zod (category, autofix, checkIds parameters)
  - [x] Implement runDoctorHandler with placeholder logic
  - [x] Return structured ToolResult: "✅ run_doctor registered (implementation pending Epic 5)"
  - [x] Export runDoctor tool definition
  - [x] Unit test: Schema validation (category enum values)
  - [x] Unit test: Schema validation (autofix boolean)
  - [x] Unit test: Schema validation (optional checkIds array)
  - [x] Unit test: Handler returns success ToolResult

- [x] **Task 4: Implement configure_hooks Tool** (AC: 1, 2, 4, 8)
  - [x] Create `src/tools/configure-hooks.ts`
  - [x] Define ConfigureHooksSchema using Zod (hookType, action, config parameters)
  - [x] Implement configureHooksHandler with placeholder logic
  - [x] Return structured ToolResult: "✅ configure_hooks registered (implementation pending Epic 4)"
  - [x] Export configureHooks tool definition
  - [x] Unit test: Schema validation (hookType enum)
  - [x] Unit test: Schema validation (action enum)
  - [x] Unit test: Schema validation (optional config object)
  - [x] Unit test: Handler returns success ToolResult

- [x] **Task 5: Implement manage_memory Tool** (AC: 1, 2, 4, 8)
  - [x] Create `src/tools/manage-memory.ts`
  - [x] Define ManageMemorySchema using Zod (action, section, content, mode parameters)
  - [x] Implement manageMemoryHandler with placeholder logic
  - [x] Return structured ToolResult: "✅ manage_memory registered (implementation pending Epic 6)"
  - [x] Export manageMemory tool definition
  - [x] Unit test: Schema validation (action enum: read/update/append/merge)
  - [x] Unit test: Schema validation (required vs optional parameters)
  - [x] Unit test: Schema validation (mode enum when action is update)
  - [x] Unit test: Handler returns success ToolResult

- [x] **Task 6: Implement get_config Tool** (AC: 1, 2, 4, 8)
  - [x] Create `src/tools/get-config.ts`
  - [x] Define GetConfigSchema using Zod (format, includeDefaults parameters)
  - [x] Implement getConfigHandler with placeholder logic
  - [x] Return structured ToolResult: "✅ get_config registered (implementation pending Epic 6)"
  - [x] Export getConfig tool definition
  - [x] Unit test: Schema validation (format enum: yaml/json)
  - [x] Unit test: Schema validation (includeDefaults boolean)
  - [x] Unit test: Handler returns success ToolResult
  - [x] Unit test: Default parameter values applied correctly

- [x] **Task 7: Register All Tools in Registry** (AC: 6, 7)
  - [x] Update `src/tools/index.ts` to import all 5 tools
  - [x] Add all tools to TOOLS array export
  - [x] Verify tools are discoverable via ListToolsRequestSchema handler
  - [x] Verify tool invocation works via CallToolRequestSchema handler
  - [x] Unit test: TOOLS array contains all 5 tools
  - [x] Unit test: Each tool has required properties (name, description, inputSchema, handler)
  - [x] Unit test: Tool names are unique in registry

- [x] **Task 8: Integration Testing** (AC: 10)
  - [x] Create `tests/integration/tool-invocation.test.ts`
  - [x] Test: tools/list returns all 5 tools with correct metadata
  - [x] Test: tools/call works for init_project
  - [x] Test: tools/call works for run_doctor
  - [x] Test: tools/call works for configure_hooks
  - [x] Test: tools/call works for manage_memory
  - [x] Test: tools/call works for get_config
  - [x] Test: tools/call with invalid tool name returns error
  - [x] Test: tools/call with invalid parameters returns ValidationError
  - [x] Test: Error responses are properly formatted

- [x] **Task 9: Comprehensive Unit Testing** (AC: 9)
  - [x] Create `tests/unit/tools/init-project.test.ts` with 8+ tests
  - [x] Create `tests/unit/tools/run-doctor.test.ts` with 8+ tests
  - [x] Create `tests/unit/tools/configure-hooks.test.ts` with 8+ tests
  - [x] Create `tests/unit/tools/manage-memory.test.ts` with 8+ tests
  - [x] Create `tests/unit/tools/get-config.test.ts` with 8+ tests
  - [x] Create `tests/unit/utils/errors.test.ts` with 6+ tests
  - [x] Verify coverage: 80%+ for all tool files
  - [x] Verify coverage: 90%+ for error utilities

## Dev Notes

### Previous Story Insights

**From Story 1.1** (COMPLETED):
- MCP server skeleton implemented with empty TOOLS array
- Type definitions already in place: MCPTool, ToolResult, ToolContent
- Server handlers ready: ListToolsRequestSchema, CallToolRequestSchema
- Logger utility available for tool logging
- Testing infrastructure (Vitest) configured and working
- Integration test pattern established in `tests/integration/mcp-protocol.test.ts`

**Key Learnings**:
- ESM module imports require `.js` extensions even for `.ts` files
- Zod schemas can be used directly as JSONSchema for MCP inputSchema
- wrapToolHandler pattern isolates error handling from tool logic
- Placeholder implementations should return clear messages about future implementation

### Architecture Overview

**Source Context**: This story implements tools described in:
- [Source: architecture/tools.md#tool-catalog]
- [Source: architecture/tools.md#tool-implementation-pattern]
- [Source: architecture/mcp-server.md#tool-system-interface]
- [Source: architecture/mcp-server.md#error-handling-strategy]

### Tool Implementation Requirements

[Source: architecture/tools.md#tool-implementation-pattern]

**Standard Tool Structure** (apply to all 5 tools):
1. Define Zod input schema
2. Infer TypeScript type from schema
3. Implement async handler function
4. Wrap handler with wrapToolHandler
5. Export tool definition with name, description, inputSchema, handler

**Common Patterns**:
- All handlers must be async (return Promise<ToolResult>)
- All parameters validated via Zod before handler execution
- All errors thrown as ContextualizerError subclasses
- All successful results return ToolResult with text content
- Placeholder implementations return friendly "coming soon" messages

### Tool Specifications

#### 1. init_project

[Source: architecture/tools.md#1-init_project]

**Parameters**:
```typescript
{
  preset: 'minimal' | 'web-fullstack' | 'hackathon' | 'custom';
  options?: {
    skipConflictCheck?: boolean;
    customConfig?: Partial<Config>;
  };
}
```

**Placeholder Behavior**: Return success message indicating tool is registered but implementation is in Epic 2.

**Expected Return**:
```typescript
{
  content: [{
    type: "text",
    text: "✅ init_project tool registered successfully.\n\nImplementation coming in Epic 2: Project Initialization\n\nThis tool will:\n- Detect existing configuration\n- Generate files from templates\n- Create .claude/hooks/user-prompt-submit\n- Create .claude/CLAUDE.md\n- Create .contextualizer/config.yaml"
  }],
  isError: false
}
```

#### 2. run_doctor

[Source: architecture/tools.md#2-run_doctor]

**Parameters**:
```typescript
{
  category?: 'all' | 'setup' | 'hooks' | 'memory' | 'mcp' | 'testing' | 'workflow';
  autofix?: boolean;
  checkIds?: string[];
}
```

**Placeholder Behavior**: Return success message indicating tool is registered but implementation is in Epic 5.

**Expected Return**:
```typescript
{
  content: [{
    type: "text",
    text: "✅ run_doctor tool registered successfully.\n\nImplementation coming in Epic 5: Diagnostics & Best Practices\n\nThis tool will:\n- Execute 15+ diagnostic checks\n- Generate structured reports\n- Apply automatic fixes when requested\n- Cache results for performance"
  }],
  isError: false
}
```

#### 3. configure_hooks

[Source: architecture/tools.md#3-configure_hooks]

**Parameters**:
```typescript
{
  hookType: 'user-prompt-submit' | 'pre-commit';
  action: 'update' | 'disable' | 'enable';
  config?: {
    strictness?: 'strict' | 'balanced' | 'relaxed';
    thresholds?: {
      warning: number;
      critical: number;
    };
    checks?: Array<{
      name: string;
      failOn: 'errors' | 'warnings' | 'never';
    }>;
  };
}
```

**Placeholder Behavior**: Return success message indicating tool is registered but implementation is in Epic 4.

**Expected Return**:
```typescript
{
  content: [{
    type: "text",
    text: "✅ configure_hooks tool registered successfully.\n\nImplementation coming in Epic 4: Context Management Hooks\n\nThis tool will:\n- Update hook configuration\n- Regenerate hooks from templates\n- Apply strictness levels\n- Create git backup commits"
  }],
  isError: false
}
```

#### 4. manage_memory

[Source: architecture/tools.md#4-manage_memory]

**Parameters**:
```typescript
{
  action: 'read' | 'update' | 'append' | 'merge';
  section?: string;
  content?: string;
  mode?: 'replace' | 'append' | 'merge';
}
```

**Validation Rules**:
- section required when action is 'update', 'append', or 'merge'
- content required when action is 'update', 'append', or 'merge'
- mode only valid when action is 'update'

**Placeholder Behavior**: Return success message indicating tool is registered but implementation is in Epic 6.

**Expected Return**:
```typescript
{
  content: [{
    type: "text",
    text: "✅ manage_memory tool registered successfully.\n\nImplementation coming in Epic 6: Memory Management & Configuration\n\nThis tool will:\n- Parse and update CLAUDE.md sections\n- Preserve user vs managed content\n- Merge lists without duplicates\n- Create git backups before modifications"
  }],
  isError: false
}
```

#### 5. get_config

[Source: architecture/tools.md#5-get_config]

**Parameters**:
```typescript
{
  format?: 'yaml' | 'json';
  includeDefaults?: boolean;
}
```

**Defaults**:
- format: 'yaml'
- includeDefaults: false

**Placeholder Behavior**: Return success message indicating tool is registered but implementation is in Epic 6.

**Expected Return**:
```typescript
{
  content: [{
    type: "text",
    text: "✅ get_config tool registered successfully.\n\nImplementation coming in Epic 6: Memory Management & Configuration\n\nThis tool will:\n- Load .contextualizer/config.yaml\n- Apply preset defaults\n- Merge environment overrides\n- Return in requested format (yaml/json)"
  }],
  isError: false
}
```

### Error Handling Architecture

[Source: architecture/mcp-server.md#error-handling-strategy]

**Error Class Hierarchy**:
```typescript
// Base class
export class ContextualizerError extends Error {
  constructor(
    message: string,
    public code: string,
    public details?: unknown,
    public recoverable: boolean = true
  ) {
    super(message);
    this.name = 'ContextualizerError';
  }
}

// Subclasses
export class ValidationError extends ContextualizerError {
  constructor(message: string, details?: unknown) {
    super(message, 'VALIDATION_ERROR', details, true);
    this.name = 'ValidationError';
  }
}

export class FileOperationError extends ContextualizerError {
  constructor(message: string, details?: unknown) {
    super(message, 'FILE_OPERATION_ERROR', details, true);
    this.name = 'FileOperationError';
  }
}

export class ConflictError extends ContextualizerError {
  constructor(message: string, details?: unknown) {
    super(message, 'CONFLICT_ERROR', details, true);
    this.name = 'ConflictError';
  }
}
```

**Tool Wrapper Pattern**:
```typescript
export function wrapToolHandler<T>(
  handler: (params: T) => Promise<ToolResult>
): (params: unknown) => Promise<ToolResult> {
  return async (params: unknown) => {
    try {
      const validatedParams = params as T; // After Zod validation
      return await handler(validatedParams);
    } catch (error) {
      if (error instanceof ContextualizerError) {
        return {
          content: [{
            type: "text",
            text: `❌ ${error.message}\n\n${error.details ? JSON.stringify(error.details, null, 2) : ''}`,
          }],
          isError: true,
        };
      }

      // Unexpected errors
      logger.error({ error }, 'Unexpected error');
      return {
        content: [{
          type: "text",
          text: `❌ Unexpected error: ${error instanceof Error ? error.message : String(error)}`,
        }],
        isError: true,
      };
    }
  };
}
```

### File Locations

[Source: architecture/integration-data.md#file-system-layout]

**New Files to Create**:
- `src/utils/errors.ts` - Error class hierarchy and wrapToolHandler
- `src/tools/init-project.ts` - init_project tool implementation
- `src/tools/run-doctor.ts` - run_doctor tool implementation
- `src/tools/configure-hooks.ts` - configure_hooks tool implementation
- `src/tools/manage-memory.ts` - manage_memory tool implementation
- `src/tools/get-config.ts` - get_config tool implementation

**Files to Modify**:
- `src/tools/index.ts` - Import and register all 5 tools in TOOLS array

**Test Files to Create**:
- `tests/unit/utils/errors.test.ts` - Error handling tests
- `tests/unit/tools/init-project.test.ts` - init_project tests
- `tests/unit/tools/run-doctor.test.ts` - run_doctor tests
- `tests/unit/tools/configure-hooks.test.ts` - configure_hooks tests
- `tests/unit/tools/manage-memory.test.ts` - manage_memory tests
- `tests/unit/tools/get-config.test.ts` - get_config tests
- `tests/integration/tool-invocation.test.ts` - Tool invocation integration tests

### Zod Schema Generation

[Source: architecture/tools.md#tool-implementation-pattern]

**Zod to JSONSchema**:
Zod schemas are automatically compatible with MCP's JSONSchema format. Use Zod's native schema types:

```typescript
import { z } from 'zod';

const ExampleSchema = z.object({
  requiredString: z.string(),
  optionalNumber: z.number().optional(),
  enumValue: z.enum(['option1', 'option2', 'option3']),
  nestedObject: z.object({
    field1: z.boolean(),
  }).optional(),
});

// Use directly as inputSchema
export const exampleTool: MCPTool = {
  name: 'example_tool',
  description: 'Tool description',
  inputSchema: ExampleSchema as any, // Cast to any for MCP compatibility
  handler: wrapToolHandler(exampleHandler),
};
```

### Logging Integration

[Source: architecture/mcp-server.md#server-lifecycle]

**Tool Logging Pattern**:
```typescript
import { logger } from '../utils/logger.js';

async function toolHandler(params: ToolParams): Promise<ToolResult> {
  logger.info({ tool: 'tool_name', params }, 'Tool invocation started');

  try {
    // Tool logic
    const result = { /* ... */ };

    logger.info({ tool: 'tool_name' }, 'Tool completed successfully');
    return result;
  } catch (error) {
    logger.error({ tool: 'tool_name', error }, 'Tool execution failed');
    throw error;
  }
}
```

**Logger Available** (from Story 1.1):
- `logger.info()` - Info level logging
- `logger.warn()` - Warning level logging
- `logger.error()` - Error level logging
- `logger.debug()` - Debug level logging
- Logs written to `.contextualizer/mcp.log`
- Structured JSON format with context fields

### Implementation Notes

**Placeholder Implementation Strategy**:
1. Tools should NOT attempt actual functionality (no file operations, no git commands)
2. Tools should validate parameters correctly (full Zod schema validation)
3. Tools should return informative success messages about future implementation
4. Tools should demonstrate proper error handling for invalid parameters
5. Each tool should clearly state which Epic will implement full functionality

**Parameter Validation**:
- Zod handles all schema validation automatically
- Invalid parameters will throw ZodError before handler is called
- wrapToolHandler converts ZodError to user-friendly ValidationError
- Test both valid and invalid parameter combinations

**Error Message Format**:
- Success: `✅ [tool_name] tool registered successfully.\n\n[Details about future implementation]`
- Validation Error: `❌ Invalid parameters: [specific validation error]\n\n[Details object]`
- Unexpected Error: `❌ Unexpected error: [error message]`

**Testing Strategy**:
- Unit tests: Focus on parameter validation and handler logic
- Integration tests: Test full MCP protocol flow (tools/list → tools/call)
- Minimum 8 tests per tool (valid params, invalid params, edge cases)
- Minimum 6 tests for error utilities (each error type, wrapping behavior)

**Dependencies** (already installed in Story 1.1):
- `zod` - Schema validation (install if not present)
- `@modelcontextprotocol/sdk` - MCP types
- `pino` - Logger (already configured)

### Testing

#### Testing Standards

[Source: architecture/security-performance-testing.md#testing-architecture]

**Test Framework**: Vitest (already configured in Story 1.1)

**Coverage Requirements**:
- Lines: 80%+
- Functions: 80%+
- Branches: 75%+
- Statements: 80%+

**Test File Structure**:
```
tests/
├── unit/
│   ├── utils/
│   │   └── errors.test.ts
│   └── tools/
│       ├── init-project.test.ts
│       ├── run-doctor.test.ts
│       ├── configure-hooks.test.ts
│       ├── manage-memory.test.ts
│       └── get-config.test.ts
└── integration/
    └── tool-invocation.test.ts
```

#### Unit Test Requirements

**Each Tool Test File Should Include**:
1. Schema validation tests (valid parameters)
2. Schema validation tests (invalid parameters)
3. Schema validation tests (optional parameters)
4. Schema validation tests (default values)
5. Handler success test (returns ToolResult)
6. Handler placeholder message test (correct Epic mentioned)
7. Error handling test (wrapped errors)
8. Tool definition test (correct name, description, schema)

**Error Utility Tests**:
1. ContextualizerError construction
2. ValidationError construction
3. FileOperationError construction
4. ConflictError construction
5. wrapToolHandler wraps ContextualizerError correctly
6. wrapToolHandler wraps unexpected errors correctly

**Example Unit Test Pattern**:
```typescript
import { describe, it, expect } from 'vitest';
import { initProject, InitProjectSchema } from '../../src/tools/init-project';

describe('init_project tool', () => {
  describe('schema validation', () => {
    it('validates correct preset values', () => {
      const valid = { preset: 'minimal' };
      expect(() => InitProjectSchema.parse(valid)).not.toThrow();
    });

    it('rejects invalid preset values', () => {
      const invalid = { preset: 'invalid' };
      expect(() => InitProjectSchema.parse(invalid)).toThrow();
    });

    it('handles optional options parameter', () => {
      const withOptions = { preset: 'minimal', options: { skipConflictCheck: true } };
      expect(() => InitProjectSchema.parse(withOptions)).not.toThrow();
    });
  });

  describe('handler behavior', () => {
    it('returns success ToolResult', async () => {
      const result = await initProject.handler({ preset: 'minimal' });
      expect(result.content[0].type).toBe('text');
      expect(result.content[0].text).toContain('✅ init_project');
      expect(result.isError).toBe(false);
    });

    it('mentions Epic 2 in placeholder message', async () => {
      const result = await initProject.handler({ preset: 'minimal' });
      expect(result.content[0].text).toContain('Epic 2');
    });
  });

  describe('tool definition', () => {
    it('has correct metadata', () => {
      expect(initProject.name).toBe('init_project');
      expect(initProject.description).toBeTruthy();
      expect(initProject.inputSchema).toBeDefined();
      expect(initProject.handler).toBeTypeOf('function');
    });
  });
});
```

#### Integration Test Requirements

[Source: architecture/security-performance-testing.md#integration-test-strategy]

**Test Scenarios**:
1. tools/list returns all 5 tools
2. tools/list includes correct metadata for each tool
3. tools/call succeeds for init_project
4. tools/call succeeds for run_doctor
5. tools/call succeeds for configure_hooks
6. tools/call succeeds for manage_memory
7. tools/call succeeds for get_config
8. tools/call with invalid tool name returns error
9. tools/call with invalid parameters returns ValidationError
10. Error responses formatted correctly

**Example Integration Test**:
```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { spawn } from 'child_process';
import type { ChildProcess } from 'child_process';

describe('Tool Invocation Integration', () => {
  let server: ChildProcess;

  beforeAll(async () => {
    server = spawn('node', ['dist/server.js']);
    // Wait for server to start
    await new Promise(resolve => setTimeout(resolve, 1000));
  });

  afterAll(() => {
    server.kill();
  });

  it('lists all 5 tools', async () => {
    server.stdin.write(JSON.stringify({
      jsonrpc: '2.0',
      method: 'tools/list',
      id: 1,
    }) + '\n');

    const response = await new Promise<any>((resolve) => {
      server.stdout.once('data', (data) => {
        resolve(JSON.parse(data.toString()));
      });
    });

    expect(response.result.tools).toHaveLength(5);
    expect(response.result.tools.map(t => t.name)).toContain('init_project');
    expect(response.result.tools.map(t => t.name)).toContain('run_doctor');
    expect(response.result.tools.map(t => t.name)).toContain('configure_hooks');
    expect(response.result.tools.map(t => t.name)).toContain('manage_memory');
    expect(response.result.tools.map(t => t.name)).toContain('get_config');
  });

  it('invokes init_project successfully', async () => {
    server.stdin.write(JSON.stringify({
      jsonrpc: '2.0',
      method: 'tools/call',
      params: {
        name: 'init_project',
        arguments: { preset: 'minimal' },
      },
      id: 2,
    }) + '\n');

    const response = await new Promise<any>((resolve) => {
      server.stdout.once('data', (data) => {
        resolve(JSON.parse(data.toString()));
      });
    });

    expect(response.result.content[0].text).toContain('✅ init_project');
    expect(response.result.isError).toBe(false);
  });
});
```

### Performance Targets

[Source: architecture/security-performance-testing.md#performance-targets]

- **Tool invocation**: < 2s (NFR1)
- **Parameter validation**: < 10ms (Zod performance)
- **Placeholder handler execution**: < 1ms (no I/O operations)

### Definition of Done

- [x] All acceptance criteria met
- [x] All tasks completed
- [x] 5 tools implemented with proper schemas and handlers
- [x] Error handling infrastructure complete
- [x] All tools registered in TOOLS array
- [x] Unit tests: 50+ tests total (8+ per tool, 6+ for errors)
- [x] Integration tests: 10+ tests covering all tools
- [x] Test coverage: 80%+ lines, functions, statements
- [x] Build completes without errors (`npm run build`)
- [x] All tests pass (`npm test`)
- [x] No TypeScript errors (`tsc --noEmit`)
- [x] Code follows established patterns from Story 1.1
- [x] Documentation comments added to all public APIs

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-19 | 1.0.0 | Initial story draft created | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
- **Model**: Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)
- **Agent**: Frank (Senior Developer)
- **Date**: 2025-10-19

### Debug Log References
- Build output: Clean build with no TypeScript errors
- Test output: 188 tests passing (129 unit + 15 integration + 44 from Story 1.1)
- Coverage report: 96.87% statements, 79.31% branches, 100% functions

### Completion Notes List

**Implementation Highlights**:
1. **Error Infrastructure**: Created comprehensive error handling with 4 error classes and wrapToolHandler pattern
2. **Zod Integration**: All tools use Zod schemas for parameter validation with type inference
3. **Server Validation**: Added automatic parameter validation in server.ts before tool invocation
4. **Placeholder Pattern**: All tools return informative messages about future Epic implementations
5. **Test Coverage**: Exceeded all coverage targets with 96.87% line coverage

**Technical Decisions**:
- Used Zod's `safeParse()` in server.ts for validation before calling handlers
- Applied `.refine()` for complex validation rules (e.g., manage_memory conditional requirements)
- Wrapped all handlers with wrapToolHandler for consistent error formatting
- Set default parameter values in Zod schemas (e.g., `category: 'all'`, `format: 'yaml'`)

**Testing Approach**:
- Unit tests cover schema validation (valid/invalid params), handler behavior, tool definitions
- Integration tests verify full MCP protocol flow: initialize → tools/list → tools/call
- Updated Story 1.1 tests to reflect new tool count (5 instead of 0)

**Challenges Resolved**:
1. Initial integration tests failed - Zod validation wasn't being applied in server
2. Solution: Added explicit validation step in CallToolRequestSchema handler
3. Old tests from Story 1.1 expected empty TOOLS array - updated to expect 5 tools

**Performance**:
- All tools execute in < 1ms (placeholder implementations)
- Parameter validation consistently < 5ms
- Integration tests complete in ~7 seconds total

### File List

**New Files Created** (13):
- `src/utils/errors.ts` - Error class hierarchy and wrapToolHandler
- `src/tools/init-project.ts` - init_project tool implementation
- `src/tools/run-doctor.ts` - run_doctor tool implementation
- `src/tools/configure-hooks.ts` - configure_hooks tool implementation
- `src/tools/manage-memory.ts` - manage_memory tool implementation
- `src/tools/get-config.ts` - get_config tool implementation
- `tests/unit/utils/errors.test.ts` - Error handling tests (16 tests)
- `tests/unit/tools/init-project.test.ts` - init_project tests (18 tests)
- `tests/unit/tools/run-doctor.test.ts` - run_doctor tests (24 tests)
- `tests/unit/tools/configure-hooks.test.ts` - configure_hooks tests (24 tests)
- `tests/unit/tools/manage-memory.test.ts` - manage_memory tests (26 tests)
- `tests/unit/tools/get-config.test.ts` - get_config tests (21 tests)
- `tests/integration/tool-invocation.test.ts` - Tool invocation integration tests (15 tests)

**Files Modified** (4):
- `src/tools/index.ts` - Registered all 5 tools in TOOLS array
- `src/server.ts` - Added Zod parameter validation in CallToolRequestSchema handler
- `tests/unit/server.test.ts` - Updated to expect 5 tools instead of 0
- `tests/unit/registries.test.ts` - Updated to expect 5 tools instead of 0

**Total Lines of Code Added**: ~2,600 lines (implementation + tests)

## QA Results

*To be filled by QA Agent*
