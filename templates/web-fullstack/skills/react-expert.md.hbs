# React Expert Skill

## Overview

Specialized skill for React development in {{projectName}}.

{{#if reactVersion}}
**Detected Version**: React v{{reactVersion}}
{{/if}}

## Expertise Areas

### Modern React Patterns

- Function components and hooks
- Custom hooks for reusable logic
- Context API for state management
- Composition patterns
- Render props and higher-order components

### Hooks Mastery

- **useState**: Local component state
- **useEffect**: Side effects and lifecycle
- **useContext**: Context consumption
- **useReducer**: Complex state logic
- **useCallback**: Memoized callbacks
- **useMemo**: Memoized values
- **useRef**: DOM references and persistent values
- **useLayoutEffect**: Synchronous effects

### Performance Optimization

- React.memo for component memoization
- useMemo and useCallback for expensive computations
- Code splitting with React.lazy and Suspense
- Virtual list rendering for large datasets
- Debouncing and throttling

### State Management

- Local state with useState/useReducer
- Global state with Context API
- External libraries (Redux, Zustand, Jotai)
- Server state (React Query, SWR)

### TypeScript Integration

- Proper component typing
- Generic components
- Event handler types
- Props and state typing
- Custom hook typing

## Common Patterns

### Custom Hook

```typescript
function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState(value)

  useEffect(() => {
    const handler = setTimeout(() => setDebouncedValue(value), delay)
    return () => clearTimeout(handler)
  }, [value, delay])

  return debouncedValue
}
```

### Context Provider

```typescript
const ThemeContext = createContext<Theme | undefined>(undefined)

export function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState<Theme>('light')
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  )
}
```

### Optimized Component

```typescript
const MemoizedComponent = memo(function MyComponent({ data }: Props) {
  const processedData = useMemo(() => expensiveOperation(data), [data])
  const handleClick = useCallback(() => {
    // handle click
  }, [])

  return <div onClick={handleClick}>{processedData}</div>
})
```

## Best Practices

- Always use TypeScript for type safety
- Keep components small and focused
- Extract reusable logic into custom hooks
- Use proper dependency arrays in useEffect
- Avoid prop drilling with Context
- Test components with React Testing Library
- Use Suspense for async boundaries

## Resources

- [React Documentation](https://react.dev)
- [React TypeScript Cheatsheet](https://react-typescript-cheatsheet.netlify.app)
- [Patterns.dev](https://www.patterns.dev/posts/reactpatterns)

---

*Generated by Contextualizer for {{projectName}}*
