# TypeScript Expert Skill

## Overview

Specialized skill for TypeScript development in {{projectName}}.

{{#if typescriptVersion}}
**Detected Version**: TypeScript v{{typescriptVersion}}
{{/if}}

## Expertise Areas

### Type System Mastery

- Primitive types and literal types
- Union and intersection types
- Type aliases and interfaces
- Generic types and constraints
- Conditional types and mapped types
- Template literal types
- Utility types (Partial, Pick, Omit, etc.)

### Advanced Patterns

- Discriminated unions for state machines
- Builder pattern with method chaining
- Factory pattern with type inference
- Type guards and type predicates
- Assertion functions
- Const assertions

### TypeScript Configuration

- Strict mode and compiler options
- Path mapping and module resolution
- Declaration files and type definitions
- Project references for monorepos

### Best Practices

- Prefer type inference over explicit types
- Use `unknown` instead of `any`
- Leverage discriminated unions for variants
- Create reusable generic utilities
- Document complex types with comments

## Common Patterns

### Generic Utility Function

```typescript
function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {
  const result = {} as Pick<T, K>
  keys.forEach(key => {
    result[key] = obj[key]
  })
  return result
}
```

### Type Guard

```typescript
interface User {
  type: 'user'
  name: string
}

interface Admin {
  type: 'admin'
  name: string
  permissions: string[]
}

type Person = User | Admin

function isAdmin(person: Person): person is Admin {
  return person.type === 'admin'
}
```

### Conditional Type

```typescript
type AsyncReturnType<T> = T extends (...args: any[]) => Promise<infer R>
  ? R
  : never

// Usage
type Result = AsyncReturnType<typeof fetchData> // infers the Promise result type
```

### Mapped Type

```typescript
type Nullable<T> = {
  [K in keyof T]: T[K] | null
}

type Optional<T> = {
  [K in keyof T]?: T[K]
}
```

## TypeScript with React

```typescript
// Component props
interface ButtonProps {
  onClick: (event: React.MouseEvent<HTMLButtonElement>) => void
  children: React.ReactNode
  variant?: 'primary' | 'secondary'
}

// Generic component
function List<T>({ items, renderItem }: {
  items: T[]
  renderItem: (item: T) => React.ReactNode
}) {
  return <ul>{items.map(renderItem)}</ul>
}
```

## Type Challenges

Practice advanced TypeScript:
- [Type Challenges](https://github.com/type-challenges/type-challenges)
- [Total TypeScript](https://www.totaltypescript.com)

## Resources

- [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)
- [TypeScript Deep Dive](https://basarat.gitbook.io/typescript/)
- [Matt Pocock's Tips](https://www.totaltypescript.com/tips)

---

*Generated by Contextualizer for {{projectName}}*
